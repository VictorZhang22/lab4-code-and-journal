Lab4 work journal:
First entry (16/12/2020 2:30pm – 3:40pm (70 minutes)):
So today I chose the first link because I am more interested in mathematical problems than biological problems. The first problem, which is to add together all the numbers that are either multiples of 3 or 5 under 1000, was simple. The biggest roadblock I experienced was to add numbers together. I was able to make python iterate from 0 – 1000 using a for loop, and I was able to make it calculate which of the numbers are multiples of 3 or 5. But I just could not figure out how to add them together. Then I added an integer (0) at the beginning of the function and added all the eligible numbers to that integer and fixed the issue. 
The second problem was much harder as I spent a long time trying to figure out how I would turn the logic of the Fibonacci sequence into Python code. So, I thought that I would start off with 2 integers, one representing the current number in the sequence and the other the previous one. And then I decided to start small, setting the sequence to no larger than 40. Then I used an if statement to select the even numbers from the sequence. After that, I had to advance in the sequence. But I had a hard time figuring out how as I got myself confused because there were two integers. At last, I figured out that the current number should add the previous number to become the new number, and the previous number should be the current number minus the previous number. 
It took me a while to figure out the logic to the third one because I did not know how to find the prime factors of a number in Python. I will do some research and solve this problem the next time I work on lab4.
I think that the three questions aren’t that challenging, and I definitely enjoyed coding to solve them. I also look forward to solving problems that involve classes and dictionaries. 

Second entry (3/1/2021 4:10pm – 5:20pm (70 minutes)):
Today I finally figured out the largest prime number problem that I was stuck on since last time. So, I started the day by practicing some find prime factor problems. After I know how to find the prime numbers, I set about drawing a diagram of the process. The diagram is shown below:

Basically, my solution is to first see if the number is divisible by 2, which is the smallest prime number. Ill stop when the number finishes the first cycle, which should produce a prime factor of the number. Then the second cycle will be done on the other factor of the original number. The program will do this time after time until there`s nothing left to analyze. I also wrote a helper function that tests to see if a number is prime or not. I call this function after the main body program has found a factor of the original number. Then I pass this new number as the argument of my helper function and determine whether it is prime or not. 

The main roadblock of today’s work was to figure out how I can turn my diagram into code. I ended up using several changeable numbers so I can reset every time I split the original number by two. Another one was to find a way to compare the prime factors. I did this after I ran my program and found that I could find all of the prime factors of a number. When I saw that Python returned 3 numbers, I immediately thought of a list so I can compare each element easily. I didn’t write a helper function for this as I think it is pretty easy to comprehend. 

In conclusion, I think today went relatively well. I did not get frustrated like I did with other projects and my train of thought remained very clear. It was very nice to take on a relatively challenging problem right after a 2-week break in which I did not do anything related to Python. I feel like that I did not forget anything and that I am ready to learn more and solve more problems. 

Third entry (10/1/2021 8:10pm – 9:20pm (70 minutes)):
So I started to work on problem 4. I drew a rough diagram of what my code will look like because one of my main issues right now is turning my diagrams into chunks of code. So, I decided to use a nested loop in order to multiple every number between 100 and 1000. After the multiplying, all results will be appended to a list. I wrote a helper function that makes sure that the numbers are all palindromes with this line: 
if str(x) == str(x)[::-1]

So, all the numbers that satisfy the statement will be appended to a new list. This list will only contain palindromes. Then I create a new variable that is the first element of the list. I then iterate through the list comparing the elements in the list to the variable. If an element from the list is bigger than the smallest variable, then I update the smallest variable to be the biggest number so far. And at the very end I simply return the smallest variable which is also the biggest palindrome. 

This problem took me less time than I thought. I think one big part is that I am drawing the diagram in a more code-like fashion. Before I use arrows or circles to indicate the steps. But this time I wrote parts of the code while creating the diagram, which made the transition easier. After I finished problem 4, I moved on to problem 5.

So, problem 5 is not as hard as it appeared to be. I did the same thing with drawing the diagram and got a clear blueprint on what the program should look like. I thought that it would be helpful to use infinity, which can be represented by math.inf in Python. I have a for loop that goes through 1 and math.inf. The if statement that follows checks if the number is divisible by all the numbers between 1 and 20. I kept on running into this problem that Python says that math.inf is a float and this float cannot be interpreted as an integer. I tried to use int(math.inf) to cast the float into an integer but Python says that the conversion can not be done.  I will seek help on Monday when I have CS. 

I think I spent the 70 mins efficiently and the process of working is pretty good. I noticed that I am using more nested loops which I think is a cool thing. I am getting more practice and it is helping me with coding more efficiently. Also I really like the new way of creating diagram as it is more simple.

Fourth entry (13/1/2021 8:20pm – 9:30pm (70 minutes))
Today I finished problem 5 and started solving problem 6. Last time I tried to use math.inf to represent infinity as I did not know which number is the smallest that also fit in the description. Today I realized that I was thinking about this all wrong and I took a different approach. The most important thing is to not miss a number, so why not start from 1 and add 1 every time the number does not fit in the description? That is exactly what today’s approach was. I created a variable i that had the value 1, and then I used an if statement which included the required criteria. If the if statement returns True, then the program stops. If the if statement returns False, then i will plus one. I wanted to stop the program after the True is returned, so I put in the line “break”. I forgot that break would only work in a loop, so I just created a while loop: while True. I specifically chose 0 because I know that the problem asks for positive numbers. This program runs fine, but it takes too long to run the program. I waited for 45 seconds before I got the results. 

Then I started on the sixth problem. This question is simple to understand and I quickly drew a diagram to outline my code. I only had time to draw the diagram but what I am thinking is to take the numbers and write two lines of code that will calculate what the problem wants. Then another which calculates the result. 

I think today’s questions are easy because they do not require complicated programs to solve. It is nice to practice more fundamental stuff like the if statement in problem 5. 

Fifth entry (17/1/2021 3:50pm – 5:00pm (70 minutes)):
Today I solved the 6 problem. Last time I thought that I would use for loops and then use another number to represent the results. Today I realized that I was not quite on track. So today I redrew my diagram and I came up with a better solution. What I did was assign two variables with the value 0, one of them is for the sum of the square of the number, the other is for the square of the sum of the numbers. So afterwards, I used a for loop to add numbers to the first variable, then squared it. I used another for loop to add squared numbers to the second variable. I could have just left it at that, but I wanted to add another small piece of code to make the problem easier to solve. So an if statement that makes sure y is greater than x, before I use y – x to calculate the difference. If x is greater than y, then x – y to get the result. 

I also started on the next problem, which was harder than I expected. I drew diagrams and tried to simplify the whole process. I think that I have a good grasp on this problem, though I was not able to figure out why my code was not executing as expected. 

Sixth entry (20/1/2021 6:20pm – 7:30pm (70 minutes)):
Today I figured out problem 7. I did it because I spotted an error when I was using a for loop. I wanted to go through every number, so I simply wanted the program to add 1 to the number I am currently testing. But I should have put the plus one line at the beginning of the while loop instead of the if statement. The while loop was set so that the list that will contain the answers will be smaller than 10001, which will give me the answer to the problem. After I ran the program, I started getting very weird numbers such as 20005, which is not a prime number. I then had to modify my isprime function because it was wrong. After that, I ran the function again but this time the function returned a long list with 10001 elements. I then entered the biggest one into the Project Euler website, but it did not work. That was when I realized that by setting the starting number as 2, I am skipping 2 and starting with 3. The list also proved to be starting with 3. So, I changed the start to 1, and then ran the function again. This time it worked very well, and I took the last element. I then wrote this: [-1], which will print the last element in the list, so I will not have to look at the list myself. 
After I finished problem 7, I started doing problem 8. I thought that problem 8 was interesting because it is like lab3, where I had to splice the list. Only this time, I decided to write the 1000-digit number as an integer. I have not gotten any success with the function because it is tricky to work with a big integer, but I have faith that I will be able to crack this problem. 
Overall, I think today went very well. I was able to troubleshoot myself and find out what kind of problems I am having with my code. 

Seventh entry (extra workday) (23/1/2021 8:00pm – 8:43pm (43 minutes)):
Today I completed problem 8, which is the last problem in this lab. When I started working on this problem last time, I thought that it would make sense if I set the 1000-digit number an integer. But last night, when I was lying in bed thinking, I realized that in Lab2, where I spliced the DNA sequences, the sequences were strings. I quickly jot the idea down and today when I was working, I entered the 1000-digit number as a string. Then, I was able to splice the string into groups of 13 or less. I appended all of them to a list. I created a function that calculates the product of the elements in the integers. I was going to use np.prod, but it does not work on strings. So afterwards I appended all of the products into a new list, and used the max() function to select the greatest number. 
I’m very happy that I put in an extra workday to finish the program because not only was the experience very satisfying but also very inspiring. I learnt a lot of new skills during the process and I practiced a lot.  

